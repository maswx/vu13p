//========================================================================
//        author   : masw
//        email    : masw@masw.tech     
//        creattime: 2023年08月20日 星期日 23时22分01秒
//========================================================================


#include "alex_iic.h"




/*
 
I2C

读取
    __    ___ ___ ___ ___ ___ ___ ___         ___ ___ ___ ___ ___ ___ ___ ___     ___ ___ ___ ___ ___ ___ ___ ___        __
sda   \__/_6_X_5_X_4_X_3_X_2_X_1_X_0_\_R___A_/_7_X_6_X_5_X_4_X_3_X_2_X_1_X_0_\_A_/_7_X_6_X_5_X_4_X_3_X_2_X_1_X_0_\_A____/
    ____   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   ____
scl  ST \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ SP

写入
    __    ___ ___ ___ ___ ___ ___ ___ ___     ___ ___ ___ ___ ___ ___ ___ ___     ___ ___ ___ ___ ___ ___ ___ ___ ___    __
sda   \__/_6_X_5_X_4_X_3_X_2_X_1_X_0_/ W \_A_/_7_X_6_X_5_X_4_X_3_X_2_X_1_X_0_\_A_/_7_X_6_X_5_X_4_X_3_X_2_X_1_X_0_/ N \__/
    ____   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   ____
scl  ST \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ SP

寄存器：

| 地址   | 名称           |
|--------|----------------|
| 0x00   | 状态           |
| 0x04   | 命令           |
| 0x08   | 数据           |
| 0x0C   | 预分频          |

状态寄存器：

| 地址   | 名称           |   位 31   |   位 30   |   位 29   |   位 28   |   位 27   |   位 26   |   位 25   |   位 24   |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x00   | 数据           |     -     |     -     |     -     |     -     |     -     |     -     |     -     |     -     |

| 地址   | 名称           |   位 23   |   位 22   |   位 21   |   位 20   |   位 19   |   位 18   |   位 17   |   位 16   |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x00   | 数据           |     -     |     -     |     -     |     -     |     -     |     -     |     -     |     -     |

| 地址   | 名称           |   位 15   |   位 14   |   位 13   |   位 12   |   位 11   |   位 10   |   位 9    |   位 8    |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x00   | 状态           |  rd_full  | rd_empty  |  wr_ovf   |  wr_full  | wr_empty  |  cmd_ovf  | cmd_full  | cmd_empty |

| 地址   | 名称           |   位 7    |   位 6    |   位 5    |   位 4    |   位 3    |   位 2    |   位 1    |   位 0    |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x00   | 状态           |     -     |     -     |     -     |     -     | miss_ack  |  bus_act  | bus_cont  |   busy    |

busy：当模块正在执行 I2C 操作时为高
bus_cont：当模块控制活动总线时为高
bus_act：总线活动时为高
miss_ack：当来自从设备的 ACK 脉冲未被检测到时设置为高；写入 1 来清除
cmd_empty：命令 FIFO 为空
cmd_full：命令 FIFO 满
cmd_ovf：命令 FIFO 溢出；写入 1 来清除
wr_empty：写入数据 FIFO 为空
wr_full：写入数据 FIFO 满
wr_ovf：写入数据 FIFO 溢出；写入 1 来清除
rd_empty：读取数据 FIFO 为空
rd_full：读取数据 FIFO 满

命令寄存器：

| 地址   | 名称           |   位 31   |   位 30   |   位 29   |   位 28   |   位 27   |   位 26   |   位 25   |   位 24   |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x04   | 数据           |     -     |     -     |     -     |     -     |     -     |     -     |     -     |     -     |

| 地址   | 名称           |   位 23   |   位 22   |   位 21   |   位 20   |   位 19   |   位 18   |   位 17   |   位 16   |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x04   | 数据           |     -     |     -     |     -     |     -     |     -     |     -     |     -     |


| 地址   | 名称           |   位 15   |   位 14   |   位 13   |   位 12   |   位 11   |   位 10   |   位 9    |   位 8    |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x04   | 命令           |     -     |     -     |     -     | cmd_stop  | cmd_wr_m  | cmd_write | cmd_read  | cmd_start |

| 地址   | 名称           |   位 7    |   位 6    |   位 5    |   位 4    |   位 3    |   位 2    |   位 1    |   位 0    |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x04   | 命令           |     -     |                               cmd_address[6:0]                                    |

cmd_address：命令的 I2C 地址
cmd_start：设置为高以发出 I2C 启动，写入以将其推入命令 FIFO
cmd_read：设置为高以开始读取，写入以将其推入命令 FIFO
cmd_write：设置为高以开始写入，写入以将其推入命令 FIFO
cmd_write_multiple：设置为高以开始块写入，写入以将其推入命令 FIFO
cmd_stop：设置为高以发出 I2C 停止，写入以将其推入命令 FIFO

允许设置多个命令位。首先会发出启动或重复启动，然后是读取或写入，最后是停止。请注意，同时设置读取和写入是不允许的，这将导致命令被忽略。

数据寄存器：

| 地址   | 名称           |   位 31   |   位 30   |   位 29   |   位 28   |   位 27   |   位 26   |   位 25   |   位 24   |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x08   | 数据           |     -     |     -     |     -     |     -     |     -     |     -     |     -     |     -     |

| 地址   | 名称           |   位 23   |   位 22   |   位 21   |   位 20   |   位 19   |   位 18   |   位 17   |   位 16   |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x08   | 数据           |     -     |     -     |     -     |     -     |     -     |     -     |     -     |     -     |

| 地址   | 名称           |   位 15   |   位 14   |   位 13   |   位 12   |   位 11   |   位 10   |   位 9    |   位 8    |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x08   | 数据           |     -     |     -     |     -     |     -     |     -     |     -     | data_last | data_valid |

| 地址   | 名称           |   位 7    |   位 6    |   位 5    |   位 4    |   位 3    |   位 2    |   位 1    |   位 0    |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x08   | 数据           |                                           data[7:0]                                           |

data：I2C 数据，写入以将其推入写入数据 FIFO，读取以从读取数据 FIFO 中拉取
data_valid：表示有效的读取数据，必须使用原子 16 位读取和写入访问
data_last：指示块写入（write_multiple）的最后一个字节，必须使用原子 16 位读取和写入访问

预分频寄存器：

| 地址   | 名称           |   位 31   |   位 30   |   位 29   |   位 28   |   位 27   |   位 26   |   位 25   |   位 24   |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x0C   | 数据           |     -     |     -     |     -     |     -     |     -     |     -     |     -     |     -     |

| 地址   | 名称           |   位 23   |   位 22   |   位 21   |   位 20   |   位 19   |   位 18   |   位 17   |   位 16   |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x0C   | 数据           |     -     |     -     |     -     |     -     |     -     |     -     |     -     |     -     |

| 地址   | 名称           |   位 15   |   位 14   |   位 13   |   位 12   |   位 11   |   位 10   |   位 9    |   位 8    |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x0C   | 预分频          |                                         prescale[15:8]                                        |

| 地址   | 名称           |   位 7    |   位 6    |   位 5    |   位 4    |   位 3    |   位 2    |   位 1    |   位 0    |
|--------|----------------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| 0x0C   | 预分频          |                                         prescale[7:0]                                         |

prescale：设置预分频值

将预分频设置为输入时钟周期的 1/4 单位，单位为输入时钟周期

prescale = Fclk / (FI2Cclk * 4)

命令：

读取
    读取数据字节
    设置 start 以强制生成起始条件
    当总线不活动或处于读取活动状态或具有不同地址时，起始条件是暗示的
    设置 stop 以在读取当前字节后发出停止条件
    如果使用读取命令设置 stop，则 data_out_last 将被设置

写入
    写入数据字节
    设置 start 以强制生成起始条件
    当总线不活动或处于写入活动状态或具有不同地址时，起始条件是暗示的
    设置 stop 以在写入当前字节后发出停止条件

多字节写入
    写入多个数据字节（直到 data_in_last）
    设置 start 以强制生成起始条件
    当总线不活动或处于读取活动状态或具有不同地址时，起始条件是暗示的
    设置 stop 以在写入块后发出停止条件

停止
    如果总线处于活动状态，则发出停止条件

状态：

busy
    模块正在通过总线通信

bus_control
    模块在活动状态下控制总线

bus_active
    总线活动，不一定由此模块控制

missed_ack
    在未检测到从设备的 ACK 时进行 strobed

参数：

prescale
    将预分频设置为输入时钟周期的 1/4 单位（prescale = Fclk / (FI2Cclk * 4)）

stop_on_idle
    当命令输入无效时自动发出停止条件

*/




u32 alex_get_status(uintptr_t baseaddr)
{
//#define ALEX_MASK_BUSY      0x00000001//当模块正在执行 I2C 操作时为高
//#define ALEX_MASK_BUS_CONT  0x00000002//当模块控制活动总线时为高
//#define ALEX_MASK_BUS_ACT   0x00000004//总线活动时为高
//#define ALEX_MASK_MISS_ACK  0x00000008//当来自从设备的 ACK 脉冲未被检测到时设置为高；写入 1 来清除
//#define ALEX_MASK_CMD_EMPTY 0x00000100//命令 FIFO 为空
//#define ALEX_MASK_CMD_FULL  0x00000200//命令 FIFO 满
//#define ALEX_MASK_CMD_OVF   0x00000400//命令 FIFO 溢出；写入 1 来清除
//#define ALEX_MASK_WR_EMPTY  0x00000800//写入数据 FIFO 为空
//#define ALEX_MASK_WR_FULL   0x00001000//写入数据 FIFO 满
//#define ALEX_MASK_WR_OVF    0x00002000//写入数据 FIFO 溢出；写入 1 来清除
//#define ALEX_MASK_RD_EMPTY  0x00004000//读取数据 FIFO 为空
//#define ALEX_MASK_RD_FULL   0x00008000//读取数据 FIFO 满
	return *(volatile u32 *) baseaddr;
}

u32 alex_get_command(uintptr_t baseaddr)
{
	return *(volatile u32 *) (baseaddr+0x4);
}

u32 alex_set_command(uintptr_t baseaddr, u32 cmd)
{
    volatile u32 *LocalAddr = (volatile u32 *)(baseaddr + 0x4);
    *LocalAddr = cmd;
	return 0;
}


u32 alex_get_fifo(uintptr_t baseaddr)
{
	return *(volatile u32 *) (baseaddr+0x8);
}

u32 alex_put_fifo(uintptr_t baseaddr, u32 data)
{
    volatile u32 *LocalAddr = (volatile u32 *)(baseaddr + 0x8);
    *LocalAddr = data;
	return 0;
}

//=====================================================================================================
//=====================================================================================================
//=====================================================================================================

int alex_iic_wb_read (uintptr_t baseaddr, u8 iicaddr, u8 regaddr, u16 *readback)
{
//读取
//    读取数据字节
//    设置 start 以强制生成起始条件
//    当总线不活动或处于读取活动状态或具有不同地址时，起始条件是暗示的
//    设置 stop 以在读取当前字节后发出停止条件
//    如果使用读取命令设置 stop，则 data_out_last 将被设置
//
//1. 写入
//    写入数据字节
//    设置 start 以强制生成起始条件
//    当总线不活动或处于写入活动状态或具有不同地址时，起始条件是暗示的
//    设置 stop 以在写入当前字节后发出停止条件

//cmd_address：命令的 I2C 地址
//cmd_start：设置为高以发出 I2C 启动，写入以将其推入命令 FIFO
//cmd_read：设置为高以开始读取，写入以将其推入命令 FIFO
//cmd_write：设置为高以开始写入，写入以将其推入命令 FIFO
//cmd_write_multiple：设置为高以开始块写入，写入以将其推入命令 FIFO
//cmd_stop：设置为高以发出 I2C 停止，写入以将其推入命令 FIFO
	//1. 写入数据字节
	alex_put_fifo   (baseaddr, ALEX_DATA_LAST | regaddr );
	//2. 写入 从机地址
	alex_set_command(baseaddr, ALEX_CMD_START | iicaddr );
	alex_set_command(baseaddr, ALEX_CMD_WRITE           );
	alex_set_command(baseaddr, ALEX_CMD_START | iicaddr );
	alex_set_command(baseaddr, ALEX_CMD_READ            );
	alex_set_command(baseaddr, ALEX_CMD_READ            );
	alex_set_command(baseaddr, ALEX_CMD_STOP            );

	while(alex_get_status(baseaddr) & ALEX_MASK_BUSY) {};

	u32 lsb = alex_get_fifo   (baseaddr);
	u32 msb = alex_get_fifo   (baseaddr);

	*readback = (msb & 0xff) << 8 | (lsb & 0xff);

	return 0;
}



int alex_iic_wb_write(uintptr_t baseaddr, u8 iicaddr, u8 regaddr, u16 *readback)
{
	
	return 0;
}
